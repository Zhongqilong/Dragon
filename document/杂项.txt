Forward
在Forward渲染路径下，每个物体会被每个光源渲染成一个“通道”，因此物体受到越多灯光的影响，其渲染次数就会越多。
Forward渲染路径的优势在于，在灯光比较少的情况下，Forward方式的渲染速度会非常快，处理透明贴图也非常快，还可以使用诸如“多重取样抗锯齿（MSAA）”这样的硬件处理技术技术。
但Forward渲染路径的渲染速度会随着灯光的增多而迅速变慢，在一些有很多灯光照明的特定场景中（比如高科技室内环境）并不适合使用Forward渲染路径。

Deferred
使用Deffered渲染路径，渲染时间不会随着灯光的增多而提高，而是会随着受整体光照影响区域的扩大而提高（也就是说，场景中越多像素被照亮，渲染速度就越慢，但全屏被照亮的情况下，灯光设置复杂度不会进一步影响渲染速度了）。
Deffered渲染路径在整体上需要更多的计算量，对于一些移动设备，Deffered渲染路径还不能支持。
新版Unity3D的默认渲染路径是Deffered渲染，如果场景非常简单，或者希望使用MSAA，可以自行修改成Forward渲染路径。

使用反射探针（Reflection Probe）
Unity3D中并没并真实的Raytrace反射，而是通过反射贴图来模拟所有的反射效果。
如果我们在场景中放置一个非常强反射的小球，我们就能看到这个小球上实际反射的是我们的Skybox，完全不会反射场景物体。这样一来不仅影响到场景中反光物体的反射正确性，同时也会严重影响整体场景的光照准确性。
我们可以为场景添加Reflection Probe来矫正不正确的反射贴图。
Reflection Probe可以看做是一个带有6个摄影机的点，它会渲染该点的6个方向（前后左右上下），将渲染结果拼成一个Cubemap，并应用给一个特定方框范围内的所有物体作为反射贴图。
对于比较复杂的环境，比如有多个区域的大房间，我们可以放置多个Reflection Probe并手动设置其影响范围。
Reflection Probe默认不会计算动态物体，仅计算烘焙物体，我们可以修改属性让其将动态物体也包括在内，同时还可以修改属性为Every Frame使其每帧更新以准确反射动态物体的运动过程，还可以增加Lighting Setting中的Reflection Bounces提高反射次数（这样就不会出现强反射物体在另一个反射物体中是黑色的情况了）。但要注意，这些修改都会占用更多的系统资源，尤其是每帧更新反射贴图这样的设置。

如何提高烘焙效率
烘焙效率虽然不影响最终游戏的表现，但对我们制作过程有很大的影响。没人会希望每次修改了场景布局或者灯光布局之后都要花费几个小时甚至几十个小时的时间来烘焙光照贴图。
一个小技巧是不要将所有物体都设置成Lightmap Static参与光照贴图的烘焙。很多细碎的物体（比如地上的小碎石）并不需要很精确的间接光照效果，而且也可能根本没有足够的光照贴图精度来对应这些细碎物体，这时候用灯光探针可能比用光照贴图更有效率。
在Unite 2017关于灯光烘焙的专场演讲中，演讲者通过将细小物体设置为动态物体，并添加简单的Light Probe，让渲染时间从3.5分钟下降到20秒。

OpenGL ES 图形管线
API获得顶点数据，将顶点数据从内存中拷贝至顶点缓冲区（显存）
拿到数据之后，通过attribute通道传递至顶点着色器，同时，纹理坐标通过Texture通道传递到顶点着色器和片元着色器
然后，图元装配，即图元的连接方式，一共有9种，常用的有6种，此步骤将顶点变换为图形
光栅化：确定图形与屏幕对应的位置
片元/片段/像素着色器：处理对应像素点的颜色值
在将处理好的每个像素点的颜色值存储到帧缓存区，然后在显示器中显示
API：可以通过API操作顶点缓冲区、顶点着色器、纹理坐标、片段着色器

混合光照模式(Mixed Lighting)
Unity里每盏灯光默认的烘焙模式都是”Realtime”，这代表这些灯光仍然会照亮你的场景，Unity的realtime GI系统会处理间接光。但如果默认的烘焙模式是”Baked”，那么这些灯光将会透过Unity的烘焙GI系统处理直接光源和间接光源，产生出来的光照贴图一旦贴到场景上在执行期间是不能改变的。选择烘焙模式为”Mixed”的话，场景内的静态对象会被烘焙GI拿去做计算，然而，不像”Baked”模式，混合模式的灯光仍会继续运算即时光源到非静态对象上，这对于你想把静态环境烘成光照贴图，但同时又希望同样一盏灯能为会动的角色计算阴影很有帮助。
改变模式为Baked，当烘焙完成后，灯光就可以删除了，已经将光照贴图赋给了游戏物体，灯光的作用已经消失了。

subtractive，在这种模式下的光照对于 动态物体只显示一个灯光阴影效果（下图左立方体，右边立方体为静态，有两个阴影）。
ShaderMask，对于动态和静态物体能都能显示完整的阴影效果。
将Shadow Mask设置为Distance Shadowmask即可使物体受其他物体的阴影影响
Baked Indirect，只烘焙间接光，其余情况均为RealTime，是最高级的模式，但当场景中距离大于Quality界面中的Shadow Distance时，所有阴影都不予显示。

很多客户给我们反馈，现在使用轻量级渲染管线LWRP，最欠缺的是二个功能：
首先是目前还未支持的Shadow Mask，这在老的内置渲染管线里已经有了。我们计划在Unity 2019.3提供Shadow Mask的功能。
其次是延迟渲染Deferred Rendering，它在老的管线有，新渲染管线没有，它也会在Unity 2019.3提供。

粒子系统的使用数量过大，从而导致其内存占用过高。对此，其最有效的优化方法还是降低粒子系统的使用数量，目前仍然建议将其数量控制在600个以下。建议研发团队后续对粒子系统的数量（特别是特效中的缓存）密切关注。

MMORPG手游的Draw Call数量普遍较高，且设备性能越好，数量峰值越高。这主要有以下几方面原因：
1）研发团队普遍开始针对不同机型来制定自适应的渲染LOD策略，主要包括模型LOD和Shader LOD等。
2）除LOD外，研发团队同样会对一些渲染效果进行有针对性的设置，最常见的是阴影的处理，高端机上开启实时阴影，而低端机上则通过较为简单的阴影面片或Projector来处理。另外，水体模拟也越来越多地在项目中被使用，高端设备上开启水面反射效果，也会增加一定量的Draw Call。
但就目前数据表明，研发团队已经开始有意地对Draw Call进行控制，UWA建议Draw Call占用的P95 < 200。

粒子系统的CPU开销普遍较低，且总体使用数量峰值在2018年后大幅降低。但我们依然建议研发团队尽可能将数量峰值控制在600以下。对此，建议研发团队经常通过以下两方面来检测自己的粒子特效使用情况：
1）粒子系统（特别是技能特效）的配置文件是否过量；
2）特效中是否含有长久不用的粒子系统。

GPU Instancing
批渲染Mesh相同的那些物体，以降低DrawCall数
这些物体可以有不同的参数，比如颜色与缩放

GPU Instancing与静态批处理，动态批处理的区别
使用静态，动态批处理物体的材质的所有参数是相同的，因为使用Renderer.sharedMaterial修改参数，则所有物体都会受影响。而使用Renderer.material会生成新实例，没法进行批处理
使用GPU Instancing的同一类物体的材质对象相同，但可以在代码中通过接口设置不同的参数，但仍会被批渲染。

1.不同材质的阴影会动态合批，只要绘制阴影的 pass是相同的，因为阴影跟其他贴图等数据无关
2.目前,只有 Mesh Renderers, Trail Renderers, Line Renderers, Particle Systems和Sprite Renderers支持合批处理，而skinned Meshes，Cloth和其他类型的渲染组件不支持合批处理。
3.渲染器仅与其他相同类型的渲染器进行合批处理。
4.对于半透明的GameObject，按照从前到后的顺序绘制，Unity首先按这个顺序对GameObjects进行排序，然后尝试对它们进行批处理，但由于必须严格满足顺序，这通常意味着对于半透明的材质更少使用合批处理。
5.手动的合并GameObject是代替合批处理的好办法，比如使用Mesh.CombineMeshes，或者直接在建模时将多个网格合并成单个网格。

